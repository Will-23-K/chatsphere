Project 2: "ChatSphere" - A Real-Time Group Chat Application
Project Description
ChatSphere is a modern, real-time group chat application that allows users to create rooms, send instant messages, see who's online, and share files. Think of it as a simplified Discord or Slack clone.

Core Features:

Real-time messaging with typing indicators

Multiple chat rooms/channels

User presence (online/offline status)

File and image sharing

Message history persistence

Responsive, modern UI

Why This Project Rocks for Your Portfolio:
âœ… WebSockets Mastery (Socket.io)

âœ… Real-time UI Updates

âœ… File Upload/Storage

âœ… Complex State Management

âœ… Authentication & Authorization

âœ… Database Design for Real-time Data

Phase Roadmap: Let's Build This Step by Step
<!--ðŸŽ¯ Phase 1: Foundation & Setup (Week 1)
Goal: Basic real-time messaging

Tasks:

Set up project structure (frontend + backend)

Choose your stack (I recommend MERN + Socket.io)

Implement Socket.io server with basic connection handling

Create simple frontend to connect to WebSocket

Build basic message sending/receiving

Display messages in real-time

Key Learning: WebSocket connections, event emission/listening-->

ðŸŽ¯ Phase 2: Rooms & Users (Week 2)
Goal: Multiple chat rooms and user management

Tasks:

User authentication (JWT)

Room creation/joining system

Display active users in room

Online/offline status

Room-based messaging isolation

Key Learning: Namespaces/rooms in Socket.io, user session management

ðŸŽ¯ Phase 3: Enhanced Features (Week 3)
Goal: Polish the core experience

Tasks:

Message persistence (MongoDB)

Message history to be shown to people that joined the chat, those that joined the chat at a later stage needs to only see messages sent after they joined like how in Whatsapp

Basic emoji support, have a tab near the message input to open a small emoji picker

Message deletion (for own messages)

Key Learning: Database design for real-time apps, advanced Socket.io features

ðŸŽ¯ Phase 4: File Sharing & UI Polish (Week 4)
Goal: Make it production-ready

Tasks:

File upload functionality

Image preview in chat

Responsive design

Notifications (browser notifications)

Deploy to production

Key Learning: File handling, deployment, responsive design

Recommended Tech Stack
Backend:

Node.js + Express

Socket.io

MongoDB/Mongoose (for messages, users, rooms)

JWT for authentication

Multer for file uploads

Frontend:

React (with hooks for real-time state)

Socket.io-client

Context API or Zustand for state management

Tailwind CSS for styling

Deployment:



Getting Started Right Now
Step 1: Initialize your project

bash
# Backend
mkdir chatsphere-backend
cd chatsphere-backend
npm init -y
npm install express socket.io mongoose bcryptjs jsonwebtoken multer cors

# Frontend (separate terminal)
npx create-react-app chatsphere-frontend
cd chatsphere-frontend
npm install socket.io-client
Step 2: Basic Socket.io server setup (server.js)

javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');

const app = express();
app.use(cors());
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"]
  }
});

// Basic connection handling
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Listen for new messages
  socket.on('send_message', (data) => {
    // Broadcast to all connected clients
    io.emit('receive_message', data);
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });
});

const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
Step 3: Basic React client (App.js)

javascript
import React, { useState, useEffect } from 'react';
import io from 'socket.io-client';

const socket = io('http://localhost:5000');

function App() {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    socket.on('receive_message', (data) => {
      setMessages(prev => [...prev, data]);
    });
  }, []);

  const sendMessage = (e) => {
    e.preventDefault();
    if (message.trim()) {
      socket.emit('send_message', {
        text: message,
        id: socket.id,
        timestamp: new Date()
      });
      setMessage('');
    }
  };
<!--
    return (
    <div className="min-h-screen bg-gray-100 p-8">
      <div className="max-w-md mx-auto bg-white rounded-lg shadow-lg">
        <div className="p-4 border-b">
          <h1 className="text-xl font-bold">ChatSphere</h1>
        </div>
        
        <div className="h-96 overflow-y-auto p-4">
          {messages.map((msg, index) => (
            <div key={index} className="mb-2">
              <div className={`p-2 rounded-lg ${msg.id === socket.id ? 'bg-blue-100 ml-8' : 'bg-gray-100 mr-8'}`}>
                {msg.text}
              </div>
            </div>
          ))}
        </div>

        <form onSubmit={sendMessage} className="p-4 border-t">
          <div className="flex gap-2">
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Type a message..."
              className="flex-1 border rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <button
              type="submit"
              className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors"
            >
              Send
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};-->

export default App;
Your Starting Challenge:
Set up the basic structure above

Get the real-time messaging working locally

Test it by opening two browser tabs and sending messages between them

Once you have this basic version working, we'll move to Phase 2 and add rooms and authentication.

